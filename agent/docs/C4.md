# C4-PlantUML — полный гайд для качественной генерации

Документ нужен для того, чтобы AI стабильно строил **понятные, корректные и полезные** C4-диаграммы в синтаксисе C4-PlantUML.

Источник стандарта и макросов: https://github.com/plantuml-stdlib/C4-PlantUML

---

## 1) Что такое C4 и зачем уровни

C4 — это модель архитектурного описания «от общего к частному»:

1. **Context** — кто взаимодействует с системой и какие внешние системы есть вокруг.
2. **Container** — из каких исполняемых частей состоит система (web, API, DB, queue и т.д.).
3. **Component** — какие внутренние компоненты есть внутри конкретного контейнера.
4. **Deployment** — где физически/логически развёрнуты контейнеры (узлы, окружения, кластеры).

Ключевая идея: **каждый уровень отвечает на свой вопрос**. Не смешивать детали компонентного уровня в контекст-диаграмме.

---

## 2) Базовые include по уровням

- Context: `!include .../C4_Context.puml`
- Container: `!include .../C4_Container.puml`
- Component: `!include .../C4_Component.puml`
- Deployment: `!include .../C4_Deployment.puml`

Рекомендуемо почти всегда:

- `LAYOUT_WITH_LEGEND()`
- при необходимости: `LAYOUT_LEFT_RIGHT()` / `LAYOUT_TOP_DOWN()`

---

## 3) Стандарт именования и качества модели

### 3.1 Alias

- Использовать стабильные алиасы в `snake_case`: `web_app`, `auth_service`, `orders_db`.
- Alias уникален во всём файле.
- Alias должен выражать роль, а не технологию (`api_gateway`, а не `node_app_1`).

### 3.2 Label

- Для людей и бизнес-аудитории: человекочитаемо и кратко.
- Не дублировать бессмысленно слова `System`, `Container` в каждом лейбле.

### 3.3 Description

- Коротко про ответственность элемента (1 фраза).
- Не писать в описании технический шум.

### 3.4 Technology/Type

- Для container/component — указывать технологию/протокол (`Spring Boot`, `PostgreSQL`, `Kafka`).
- Для Person/System можно использовать `$type`, если нужно дополнительное обозначение.

---

## 4) Рекомендуемый формат аргументов (обязательно)

Использовать **именованные аргументы** (`$name=value`) вместо позиционных.

### 4.1 Элементы

```plantuml
Person($alias=employee, $label="Сотрудник клиники", $descr="Использует ИС ветеринарной клиники")
System($alias=clinic_system, $label="ИС ветеринарной клиники", $type="Core", $descr="Автоматизация процессов клиники")
Container($alias=web_app, $label="Веб-приложение", $techn="Java Spring", $descr="Рабочее место сотрудника")
ContainerDb($alias=clinic_db, $label="База данных", $techn="PostgreSQL", $descr="Хранит операционные данные")
```

### 4.2 Связи

```plantuml
Rel($from=employee, $to=web_app, $label="Использует", $techn="HTTPS")
Rel_R($from=web_app, $to=clinic_db, $label="Читает и пишет", $techn="JDBC")
Rel_D($from=web_app, $to=notification_queue, $label="Публикует события", $techn="AMQP")
```

---

## 5) Слои C4 — правила, элементы и когда применять

## 5.1 Context

### Цель

Показать границы системы и её взаимодействия с пользователями/внешними системами.

### Что включать

- `Person`, `Person_Ext`
- `System`, `System_Ext`
- при необходимости границы: `Boundary`, `Enterprise_Boundary`, `System_Boundary`

### Что НЕ включать

- внутренние контейнеры (`Container`) и уж тем более компоненты.
- низкоуровневые протоколы на уровне деталей реализации (допускаются только ключевые).

### Когда использовать

- старт обсуждения архитектуры;
- презентация стейкхолдерам;
- согласование внешних интеграций.

---

## 5.2 Container

### Цель

Показать внутреннюю композицию системы как набор исполняемых/хранимых частей.

### Основные элементы

- `Container`, `Container_Ext`
- `ContainerDb`, `ContainerDb_Ext`
- `ContainerQueue`, `ContainerQueue_Ext`
- окружение людей/внешних систем: `Person`, `System`, `System_Ext`

### Когда использовать

- проектирование интеграций между приложениями;
- выделение границ ответственности команд;
- обсуждение API, очередей, БД на архитектурном уровне.

### Практика

- Для каждого контейнера: **роль + технология + краткое назначение**.
- Для связей: действие + протокол (`Читает`, `Пишет`, `Вызывает`, `Публикует`).

---

## 5.3 Component

### Цель

Разобрать конкретный контейнер на внутренние архитектурные части.

### Основные элементы

- `Component`, `Component_Ext`
- `ComponentDb`, `ComponentQueue`
- контейнер и внешние системы как контекст окружения

### Когда использовать

- детальная проработка backend-сервиса;
- подготовка к реализации или рефакторингу;
- объяснение модулей внутри одного приложения.

### Практика

- Не переносить в компонентный слой инфраструктурный шум всего ландшафта.
- Показывать только значимые компоненты (3–12 обычно достаточно).

---

## 5.4 Deployment

### Цель

Показать, где и как контейнеры размещаются по узлам/окружениям.

### Основные элементы

- `Deployment_Node`, `Node`, `Node_L`, `Node_R`
- `Container`, `ContainerDb`, `ContainerQueue`

### Когда использовать

- эксплуатация, DevOps, SRE обсуждения;
- high availability, zoning, network segments;
- анализ отказоустойчивости и окружений (dev/stage/prod).

### Практика

- Группировать узлы по средам/зонам.
- Ясно указывать границы: cloud/account/region/cluster.

---

## 6) Элементы и когда какой выбирать

## 6.1 Люди и системы

- `Person` — основной пользователь/роль внутри рассматриваемой границы.
- `Person_Ext` — внешний пользователь относительно системы в фокусе.
- `System` — целевая или соседняя внутренняя система.
- `System_Ext` — внешняя система (vendor, госреестр, платежка и т.п.).

## 6.2 Данные и обмен

- `ContainerDb` / `ComponentDb` — если это именно хранилище данных.
- `ContainerQueue` / `ComponentQueue` — если это брокер/очередь/стрим.
- `Container` / `Component` — вычислительная логика/приложение.

## 6.3 Границы

- `System_Boundary` — основная граница системы.
- `Container_Boundary` — внутренняя область контейнера (на component-уровне).
- `Enterprise_Boundary` — корпоративная/организационная рамка.
- `Boundary` — универсальная логическая группировка.

---

## 7) Связи — как писать качественно

### 7.1 Выбор типа связи

- `Rel` — базовая, без принудительного направления размещения.
- `Rel_U|D|L|R` — применять точечно, когда нужно поправить layout.
- `Rel_Neighbor` — близкие элементы на схеме.
- `BiRel*` — только если взаимодействие действительно двустороннее и это важно показать.

### 7.2 Формулировка label

Хорошо:

- `Читает и пишет`
- `Публикует события`
- `Запрашивает профиль`

Плохо:

- `Связь`
- `Интеграция`

### 7.3 Technology

Писать конкретику:

- `HTTPS/REST`
- `gRPC`
- `JDBC`
- `AMQP`

---

## 8) Визуальные правила и layout

1. Сначала объявить все элементы, потом связи.
2. Минимизировать количество направленных `Rel_*` и `Lay_*`.
3. Использовать легенду (`LAYOUT_WITH_LEGEND`/`SHOW_LEGEND`) для читаемости.
4. Избегать «лапши» из стрелок — лучше разбить на несколько диаграмм.
5. Для больших схем предпочитать left-to-right (`LAYOUT_LEFT_RIGHT`).

---

## 9) Антипаттерны (чего избегать)

- Смешение уровней: компоненты в context-диаграмме.
- Слишком много элементов на одном полотне без разбиения.
- Непонятные alias (`a1`, `x2`, `tmp`).
- Отсутствие технологий/протоколов там, где они критичны.
- Дублирующиеся связи с одинаковым смыслом.

---

## 10) Шаблоны по уровням

## 10.1 Context skeleton

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml
LAYOUT_WITH_LEGEND()

title [Context] Название системы

Person($alias=user, $label="Пользователь", $descr="Использует систему")
System($alias=target, $label="Целевая система", $descr="Основной домен")
System_Ext($alias=ext_sys, $label="Внешняя система", $descr="Интеграция")

Rel($from=user, $to=target, $label="Использует", $techn="HTTPS")
Rel($from=target, $to=ext_sys, $label="Обменивается данными", $techn="API")
@enduml
```

## 10.2 Container skeleton

```plantuml
@startuml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
LAYOUT_WITH_LEGEND()

title [Containers] Название системы

Person($alias=user, $label="Сотрудник")
System_Boundary($alias=sys, $label="ИС") {
  Container($alias=web, $label="Web", $techn="Next.js", $descr="UI")
  Container($alias=api, $label="API", $techn="Node.js", $descr="Бизнес-логика")
  ContainerDb($alias=db, $label="DB", $techn="PostgreSQL", $descr="Операционные данные")
}

Rel($from=user, $to=web, $label="Использует", $techn="HTTPS")
Rel($from=web, $to=api, $label="Вызывает", $techn="REST")
Rel($from=api, $to=db, $label="Читает/пишет", $techn="SQL")
@enduml
```

---

## 11) Правила для AI при генерации ответов

1. Всегда учитывать `currentSource` (текущее состояние кода).
2. Предлагать минимально достаточные изменения.
3. Возвращать итоговый полный `nextSource`, а не только дельту.
4. Соблюдать слой, выбранный пользователем.
5. При неоднозначности делать консервативное предположение и явно фиксировать его в `summary`/`operations`.
6. Не переименовывать существующие alias без явного запроса.

---

## 12) Чек-лист качества перед выдачей результата

- [ ] Диаграмма соответствует выбранному уровню (Context/Container/Component/Deployment).
- [ ] Все alias уникальны и осмысленны.
- [ ] У связей есть понятные `label`.
- [ ] Для важных связей указаны `techn`.
- [ ] Нету явных визуальных конфликтов (чрезмерных пересечений).
- [ ] Нет дублирующих или противоречивых элементов.
- [ ] Используются именованные аргументы.

Если все пункты выполнены — ответ считается архитектурно качественным.
